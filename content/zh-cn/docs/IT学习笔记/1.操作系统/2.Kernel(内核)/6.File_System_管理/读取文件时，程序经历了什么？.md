---
title: 读取文件时，程序经历了什么？
---

<https://mp.weixin.qq.com/s?__biz=Mzg4OTYzODM4Mw==&mid=2247485706&idx=1&sn=bc5d6e4bf9ee5dccef520e5b2051d943&source=41#wechat_redirect>

承接上文《看完这篇还不懂高并发中的线程与线程池你来打我》，这是高性能、高并发系列的第二篇文章，在这里我们来到了 I/O 这一话题。

码农的荒岛求生：图解 | 看完这篇还不懂高并发中的线程与线程池你来打我 zhuanlan.zhihu.com

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569949-61c844f7-bb43-4068-899f-7ca8a0631e14.jpeg)

你有没有想过当我们执行 I/O 操作时计算机底层都发生了些什么？

在回答这个问题之前，我们先来看下为什么对于计算机来说 I/O 是极其重要的。

## **不能执行 I/O 的计算机是什么？**

相信对于程序员来说 I/O 操作是最为熟悉不过的了：

当我们使用 C 语言中的 printf、C++中的"<<"，Python 中的 print，Java 中的 System.out.println 等时，这是 I/O；当我们使用各种语言读写文件时，这也是 I/O；当我们通过 TCP/IP 进行网络通信时，这同样是 I/O;当我们使用鼠标龙飞凤舞时，当我们扛起键盘在评论区里指点江山亦或是埋头苦干努力制造 bug 时、当我们能看到屏幕上的漂亮的图形界面时等等，这一切都是 I/O。

想一想，如果没有 I/O 计算机该是一种多么枯燥的设备，不能看电影、不能玩游戏，也不能上网，这样的计算机最多就是一个大号的计算器。

既然 I/O 这么重要，那么到底什么才是 I/O 呢？

## **什么是 I/O**

I/O 就是简单的**数据 Copy**，仅此而已。

这一点很重要，为了加深大家的印象，来，Everybody，Follow me，那边树上的朋友，还有那边墙上的朋友们，举起你们的双手，跟我唱，苍茫的天涯是。。。Sorry，I/O 仅仅就是数据 copy、I/O 仅仅就是数据 copy。

让我们先把演唱会的事情放在一边，既然是 copy 数据，又是从哪里 copy 到哪里呢？

如果数据是从外部设备 copy 到内存中，这就是 Input。

如果数据是从内存 copy 到外部设备，这就是 Output。

**内存与外部设备之间不嫌麻烦的来回 copy 数据就是 Input and Output，简称 I/O**（Input/Output），仅此而已。

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569957-0700ad3d-4f0a-4f25-a308-bf8fa3bc9259.jpeg)

## **I/O 与 CPU**

现在我们知道了什么是 I/O，接下来就是重点部分了，大家注意，坐稳了。

我们知道现在的 CPU 其主频都是数 GHz 起步，这是什么意思呢？简单说就是 CPU 执行机器指令的速度是纳秒级别的，而通常的 I/O 比如磁盘操作，一次磁盘 seek 大概在毫秒级别，**因此如果我们把 CPU 的速度比作战斗机的话，那么 I/O 操作的速度就是肯德鸡**。

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569966-3f124af4-18e4-4c8a-98c1-793d3e2c3a9e.jpeg)

也就是说当我们的程序跑起来时(CPU 执行机器指令)，其速度是要远远快于 I/O 速度的，那么接下来的问题就是二者速度相差这么大，那么我们该如何设计、该如何更加合理的高效利用系统资源呢？

既然有速度差异，而且进程在执行完 I/O 操作前不能继续向前推进，那么显然只有一个办法，那就是**等待，wait**。

同样是等待，有聪明的等待，也有傻傻的等待，简称傻等，那么是选择聪明的等待呢还是选择傻等呢？

假设你是一个急性子(CPU)，需要等待一个重要的文件，不巧的是这个文件只能快递过来(I/O)，那么这时你是选择什么事情都不干了，深情的注视着门口就像盼望着你的哈尼一样专心等待这个快递呢？还是暂时先不要管快递了，玩个游戏看个电影刷会儿短视频等快递来了再说呢？

很显然，更好的方法就是先去干其它事情，快递来了再说。

**因此这里的关键点就是快递没到前手头上的事情可以先暂停，切换到其它任务，等快递过来了再切换回来**。

理解了这一点你就能明白执行 I/O 操作时底层都发生了什么。

接下来让我们以读取磁盘文件为例来讲解这一过程。

## **执行 I/O 时底层都发生了什么**

在上一篇《一文彻底理解高并发高性能中的线程与线程池》中，我们引入了进程和线程的概念，在支持线程的操作系统中，实际上被调度的是线程而不是进程，为了更加清晰的理解 I/O 过程，我们暂时假设操作系统只有进程这样的概念，先不去考虑线程，这并不会影响我们的讨论。

现在内存中有两个进程，进程 A 和进程 B，当前进程 A 正在运行，如图所示：

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569940-d2d3bdbc-c805-4f6e-bdbc-2b7a04cdecb6.jpeg)

进程 A 中有一段读取文件的代码，不管在什么语言中通常我们定义一个用来装数据的 buff，然后调用 read 之类的函数，像这样：

    read(buff);

这就是一种典型的 I/O 操作，当 CPU 执行到这段代码的时候会向磁盘发送读取请求，注意与 CPU 执行指令的速度相比，I/O 操作操作是非常慢的，因此操作系统是不可能把宝贵的 CPU 计算资源浪费在无谓的等待上的，这时重点来了，注意接下来是重点哦。

由于外部设备执行 I/O 操作是相当慢的，因此在 I/O 操作完成之前进程是无法继续向前推进的，这就是所谓的**阻塞**，即通常所说的 block。操作系统检测到进程向 I/O 设备发起请求后就暂停进程的运行，怎么暂停运行呢？很简单，只需要记录下当前进程的运行状态并把 CPU 的 PC 寄存器指向其它进程的指令就可以了。

进程有暂停就会有继续执行，因此操作系统必须保存被暂停的进程以备后续继续执行，显然我们可以用队列来保存被暂停执行的进程，如图所示，进程 A 被暂停执行并被放到阻塞队列中(注意，不同的操作系统会有不同的实现，可能每个 I/O 设备都有一个对应的阻塞队列，但这种实现细节上的差异不影响我们的讨论)。

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569940-4c41239e-bb6f-42a4-9111-8ca9b2ed634d.jpeg)

这时操作系统已经向磁盘发送了 I/O 请求，因此磁盘 driver 开始将磁盘中的数据 copy 到进程 A 的 buff 中，虽然这时进程 A 已经被暂停执行了，但这并不妨碍磁盘向内存中 copy 数据。注意，现代磁盘向内存 copy 数据时无需借助 CPU 的帮助，这就是所谓的 DMA(Direct Memory Access)，这个过程如图所示：

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569921-5b8dc049-61a5-498e-ae21-4adb68bd49e5.jpeg)

让磁盘先 copy 着数据，我们接着聊。

实际上操作系统中除了有阻塞队列之外也有**就绪**队列，所谓就绪队列是指队列里的进程准备就绪可以被 CPU 执行了，你可能会问为什么不直接执行非要有个就绪队列呢？答案很简单，那就是**僧多粥少**，在即使只有 1 个核的机器上也可以创建出成千上万个进程，CPU 不可能同时执行这么多的进程，因此必然存在这样的进程，**即使其一切准备就绪也不能被分配到计算资源**，这样的进程就被放到了就绪队列。

现在进程 B 就位于就绪队列，万事俱备只欠 CPU，如图所示：

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569959-d7bf4862-5f3a-402f-94f3-ec2d8e31e121.jpeg)

当进程 A 被暂停执行后 CPU 是不可以闲下来的，因为就绪队列中还有嗷嗷待哺的进程 B，这时操作系统开始在就绪队列中找下一个可以执行的进程，也就是这里的进程 B。

此时操作系统将进程 B 从就绪队列中取出，找出进程 B 被暂停时执行到的机器指令的位置，然后将 CPU 的 PC 寄存器指向该位置，这样进程 B 就开始运行啦，如图所示：

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569941-4a2d092b-f747-43b4-abbc-6a8e238b4cbe.jpeg)

注意，注意，接下来的这段是重点中的重点。

注意观察上图，此时进程 B 在被 CPU 执行，磁盘在向进程 A 的内存空间中 copy 数据，看出来了吗，**大家都在忙，谁都没有闲着，数据 copy 和指令执行在同时进行**，在操作系统的调度下，CPU、磁盘都得到了**充分**的利用，这就是程序员的智慧所在。

**现在你应该理解为什么操作系统这么重要了吧。**

此后磁盘终于将全部数据都 copy 到了进程 A 的内存中，这时磁盘通知操作系统任务完成啦，你可能会问怎么通知呢？这就是中断。

操作系统接收到磁盘中断后发现数据 copy 完毕，进程 A 重新获得继续运行的资格，这时操作系统小心翼翼的把进程 A 从阻塞队列放到了就绪队列当中，如图所示：

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569942-ce92b9c9-06b3-4c3e-99e7-bc5d7777795b.jpeg)

注意，从前面关于就绪状态的讨论中我们知道，操作系统是不会直接运行进程 A 的，进程 A 必须被放到就绪队列中等待，这样对大家都公平。

此后进程 B 继续执行，进程 A 继续等待，进程 B 执行了一会儿后操作系统认为进程 B 执行的时间够长了，因此把进程 B 放到就绪队列，把进程 A 取出并继续执行。

注意操作系统把进程 B 放到的是就绪队列，因此进程 B 被暂停运行仅仅是因为时间片到了而不是因为发起 I/O 请求被阻塞，如图所示：

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/funqnh/1616167569968-658743aa-149f-402d-a608-676638aa4868.jpeg)

进程 A 继续执行，**此时 buff 中已经装满了想要的数据，进程 A 就这样愉快的运行下去了，就好像从来没有被暂停过一样，进程对于自己被暂停一事一无所知，这就是操作系统的魔法**。

现在你应该明白了 I/O 是一个怎样的过程了吧。

这种进程执行 I/O 操作被阻塞暂停执行的方式被称为阻塞式 I/O，blocking I/O，这也是最常见最容易理解的 I/O 方式，有阻塞式 I/O 就有非阻塞式 I/O，在这里我们暂时先不考虑这种方式。

在本节开头我们说过暂时只考虑进程而不考虑线程，现在我们放宽这个条件，实际上也非常简单，只需要把前图中调度的进程改为线程就可以了，这里的讨论对于线程一样成立。

## **零拷贝，Zero-copy**

最后需要注意的一点就是上面的讲解中我们直接把磁盘数据 copy 到了进程空间中，**但实际上一般情况下 I/O 数据是要首先 copy 到操作系统内部，然后操作系统再 copy 到进程空间中**。因此我们可以看到这里其实还有一层经过操作系统的 copy，对于性能要求很高的场景其实也是可以绕过操作系统直接进行数据 copy 的，这也是本文描述的场景，这种绕过操作系统直接进行数据 copy 的技术被称为**Zero-copy**，也就零拷贝，高并发、高性能场景下常用的一种技术，原理上很简单吧。

## **总结**

本文讲解的是程序员常用的 I/O，一般来说作为程序员我们无需关心，但是理解 I/O 背后的底层原理对于设计高性能、高并发系统是极为有益的，希望这篇能对大家加深对 I/O 的认识有所帮助。
