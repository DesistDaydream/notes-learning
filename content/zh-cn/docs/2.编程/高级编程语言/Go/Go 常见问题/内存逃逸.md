---
title: "内存逃逸"
linkTitle: "内存逃逸"
date: "2023-08-25T13:43"
weight: 20
---

# 概述

> 参考：
>
> - [腾讯云，简单聊聊内存逃逸](https://cloud.tencent.com/developer/article/1797578)
> - [51CTO，Go 语言中的逃逸分析作用](https://blog.51cto.com/u_13482767/5674384)

前置知识： [Heap and Stack](/docs/2.编程/计算机科学/Heap%20and%20Stack.md)，必须要了解编程中，哪些情况会使用到 Stack，哪些情况会使用到 Heap。

Go 语言的内存逃逸通常都是指从变量所在的内存地址(i.e. 指针)从 Stack 变为 Heap，此时指针的值将会发生改变。下面是一个最直观的示例：

```go
 in1 := []int{1, 2, 3}
 in2 := []string{"4", "5"}

 for i, v1 := range in1 {
  fmt.Printf("循环 %v\n", i+1)
  // 外层循环并不会发生逃逸现象
  // fmt.Printf("v1-Dec: %v\n", &v1)

  for _, v2 := range in2 {
   println("v1-Hex: ", &v1, "v2-Hex: ", &v2)
   // TODO: fmt 有逃逸问题？ https://juejin.cn/post/6955453411969990670, append 好像也有类似的内存逃逸现象
   // 正常情况下，v2 的指针应该也是一样的，但是用了 fmt 之后，指针的值在外层循环的下一次迭代中产生了变化
   fmt.Printf("v1-Dec: %v, v2-Dec: %v\n", &v1, &v2)
  }
 }
```

输出结果：

```text
循环 1
v1-Hex:  0xc0000cc2c0 v2-Hex:  0xc0000b66a0
v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66a0
v1-Hex:  0xc0000cc2c0 v2-Hex:  0xc0000b66a0
v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66a0
循环 2
v1-Hex:  0xc0000cc2c0 v2-Hex:  0xc0000b66b0
v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66b0
v1-Hex:  0xc0000cc2c0 v2-Hex:  0xc0000b66b0
v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66b0
循环 3
v1-Hex:  0xc0000cc2c0 v2-Hex:  0xc0000b66c0
v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66c0
v1-Hex:  0xc0000cc2c0 v2-Hex:  0xc0000b66c0
v1-Dec: 0xc0000cc2c0, v2-Dec: 0xc0000b66c0
```

`go 程序变量`会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在`栈上`分配。否则就说它 `逃逸` 了，必须在`堆上分配`。

能引起变量逃逸到堆上的**典型情况**：

- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。

## **举例**

- 通过一个例子加深理解，接下来尝试下怎么通过 `go build -gcflags=-m` 查看逃逸的情况。

```javascript
package main
import "fmt"
type A struct {
 s string
}
// 这是上面提到的 "在方法内把局部变量指针返回" 的情况
func foo(s string) *A {
 a := new(A)
 a.s = s
 return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆
}
func main() {
 a := foo("hello")
 b := a.s + " world"
 c := b + "!"
 fmt.Println(c)
}
```

执行`go build -gcflags=-m main.go`

```javascript
go build -gcflags=-m main.go
# command-line-arguments
./main.go:7:6: can inline foo
./main.go:13:10: inlining call to foo
./main.go:16:13: inlining call to fmt.Println
/var/folders/45/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/go-build409982591/b001/_gomod_.go:6:6: can inline init.0
./main.go:7:10: leaking param: s
./main.go:8:10: new(A) escapes to heap
./main.go:16:13: io.Writer(os.Stdout) escapes to heap
./main.go:16:13: c escapes to heap
./main.go:15:9: b + "!" escapes to heap
./main.go:13:10: main new(A) does not escape
./main.go:14:11: main a.s + " world" does not escape
./main.go:16:13: main []interface {} literal does not escape
<autogenerated>:1: os.(*File).close .this does not escape
```

复制

- `./main.go:8:10: new(A) escapes to heap` 说明 `new(A)` 逃逸了,符合上述提到的常见情况中的第一种。
- `./main.go:14:11: main a.s + " world" does not escape` 说明 `b` 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。
- `./main.go:15:9: b + "!" escapes to heap` 说明 `c` 变量逃逸，通过`fmt.Println(a ...interface{})`打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。
