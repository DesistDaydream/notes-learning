---
title: "复合数据类型"
linkTitle: "复合数据类型"
weight: 20
---

# 概述
> 参考：
> - [Wiki，Composite_data_type](https://en.wikipedia.org/wiki/Composite_data_type)

原子类型的值是不能分解为组成部分的单个数据项。复合类型 或 聚合类型 的值是可以单独访问的数据项的集合。例如，一个整数通常被认为是原子的，尽管它由一系列位组成，而整数数组肯定是复合的。

# Array(数组)

**为什么很多编程语言要把 0 作为第一个下标索引，而不是直观的 1 呢？**

这个问题 Dijkstra 已经解答过了，没错，就是你知道的 Dijkstra，Dijkstra 最短路径算法，荷兰语全名是 Edsger Wybe Dijkstra，于 1972 年获得了图灵奖，除了上面说的最短路径算法，还有众所周知的信号量和 PV 原语、银行家算法等也是这位巨佬提出的。

原文在这里：https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html，感兴趣的小伙伴可以去看下全文，下面我总结几段核心的观点：

首先来看个案例，如何用一个不等式（或者说表达式）来表示 `[2,3,4,5,6,7,8,9,10,11,12]` 这个连续的整数序列（一共 11 个数）？

假设 `i` 是一个整数，那么我们能够迅速的写出如下四个符合上述连续序列的不等式：

1）`2 <= i < 13`

2）`1 < i <= 12`

3）`2 <= i <= 12`

4）`1 < i < 13`

以上四个不等式均满足要求，那是否有理由选择其中的一种而不是另一种？

Dijkstra 说有的，选 1 和 2，因为这俩不等式有个很突出的有点，就是不等式边界的差（不等式右边 \- 不等式左边）正好等于连续序列的长度

这里可以排除掉 3 和 4，那么 1 和 2 该如何选出最优的表示？

1 和 2 不等式的区别就在于：
*   1 不等式左边（下界）等于序列中的最小值，不等式右边（上界）大于序列中的最大值
*   2 不等式左边（下界）小于序列中的最小值，不等式右边（上界）等于序列中的最大值

对于第 2 个不等式来说，下界小于序列中的最小值，这会出现一个问题，比如我们的连续序列是 `[0,1,2,3,4]`

那么按照第 2 个不等式的写法，不等式的左边就是 -1，-1 是非自然数，而我们需要表示的连续序列是自然数序列，所以第 2 个不等式很不优雅：我们需要用一个 非自然数 来作为 全是自然数的序列 的下界

因此，综上所述，不等式 1 是最优雅的选择。

那么，选出一个看着非常顺眼的不等式来表达长度为 N 的连续序列之后，下一个令人烦恼的问题是该为起始元素分配什么下标值？

遵循不等式 1 的规则：
*   当从下标 1 开始时，下标范围 `1 ≤ i < N+1`
*   当从下标 0 开始时，下标范围 `0 ≤ i < N`

哪个更优雅？

Dijkstra 是这样解释的：从下标 0 开始能够给出更好的不等式，因为元素的下标就等于序列中它前面的元素数（或者说 “偏移量”）。

