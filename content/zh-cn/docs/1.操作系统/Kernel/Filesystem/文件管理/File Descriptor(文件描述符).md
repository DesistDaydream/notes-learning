---
title: File Descriptor(文件描述符)
linkTitle: File Descriptor(文件描述符)
weight: 4
---

# 概述

> 参考
>
> - [Wiki, FileDescriptor](https://en.wikipedia.org/wiki/File_descriptor)
> - [CSDN，Linux 中的文件描述符与打开文件之间的关系](https://blog.csdn.net/cywosp/article/details/38965239)

**File Descriptor(文件描述符，简称 FD，**有的地方也称为**Handle(句柄))** 是一个抽象的指示符(也可以称为**索引**)，用于应用程序便捷得访问文件或其他 I/O 资源。

在 Linux 系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件、设备文件等等。**File Descriptor(文件描述符)** 是内核为了高效管理**已被打开**的文件所创建的**索引值**，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行 I/O 操作的系统调用都通过文件描述符。

每个进程(除了 Daemon 进程)，一般总是会打开三个文件(/dev/null 或 /dev/pts/0 或其他等等)，并占用前三个文件描述符，0 是标准输入，1 是标准输出，2 是标准错误。比如现在有这么一个程序，我们打开它:

```bash
cat > test-fd.sh <<EOF
#!/bin/bash
while true; do
 date
    sleep 10
done
EOF
chmod 755 test-fd.sh

bash test-fd.sh
# 查看该进程的 fd 目录可以看到有如下几个文件
~]# ll /proc/4082/fd
total 0
lrwx------ 1 root root 64 Nov 22 18:27 0 -> /dev/pts/0
lrwx------ 1 root root 64 Nov 22 18:27 1 -> /dev/pts/0
lrwx------ 1 root root 64 Nov 22 18:27 2 -> /dev/pts/0
lr-x------ 1 root root 64 Nov 22 18:27 255 -> /root/test-fd.sh
# 其实，正常情况下,第四个文件描述符的编号应该是3，但是 bash 命令比较不同，直接占用了 255 号
```

POSIX 标准要求每次打开文件时（含 socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话。标准文件描述符图如下：
![](https://notes-learning.oss-cn-beijing.aliyuncs.com/thtg9e/1616167666390-f897f58e-e359-475d-bb6d-32dc733bb0c5.jpeg)
文件描述与打开的文件对应模型如下图：
![](https://notes-learning.oss-cn-beijing.aliyuncs.com/thtg9e/1616167666236-6602a2d4-45dd-45b9-a112-ec3ffe7b4708.png)
要想读取比如磁盘数据我们需要指定一个 buff 用来装入数据，是这样用的：

```c
read(buff);
```

但是这里我们忽略了一个问题，那就是虽然我们执行了往哪里写数据，但是我们该从哪里读数据呢？从上一节中我们知道，通过文件这个概念我们能实现几乎所有 I/O 操作，**因此这里少的一个主角就是文件**。

那么我们一般都这么使用文件呢？

如果你周末去比较火的餐厅吃饭应该会有体会，一般周末这样的餐厅都会排队，然后服务员会给你一个排队序号，通过这个序号服务员就能找到你，这里的好处就是服务员无需记住你是谁、你的名字是什么、是不是保护环境爱好小动物等等，这里的关键点就是**服务员对你一无所知，但是依然可以通过一个号码就能找到你**。

同样的，在 Linux 世界使用文件，我们也需要借助一个号码，根据“弄不懂原则”，这个号码就被称为了文件描述符**file** **descriptors**，在 Linux 世界中鼎鼎大名，其道理和上面那个排队号码一样。

因此，文件描述仅仅就是一个数字而已，但是通过这个数字我们可以操作一个打开的文件，这一点要记住。

有了文件描述符，进程对文件一无所知，比如文件在磁盘的什么位置上、内存是如何管理文件的等等，这些信息属于操作系统，进程无需关心，操作系统只需要给进程一个文件描述符就足够了。

因此我们来完善上述程序：

    int fd = open(file_name);
    read(fd, buff);

## 文件描述限制

在编写文件操作的或者网络通信的软件时，可能会遇到“Too many open files”的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的 10%（以 KB 来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用 `sysctl -a | grep fs.file-max` 命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是 1024，使用 `ulimit -n` 命令可以查看。在 Web 服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看<http://blog.csdn.net/kumu_linux/article/details/7877770>。

## 文件描述符和打开文件之间的关系

每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从 0 开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的 3 个数据结构。

- 进程级的文件描述符表
- 系统级的打开文件描述符表
- 文件系统的 inode 表

进程级的描述符表的每一条目记录了单个文件描述符的相关信息。

- 控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即 close-on-exec 标志）
- 对打开文件句柄的引用

内核对所有打开的文件的文件维护有一个系统级的描述符表格（open file description table）。有时，也称之为打开文件表（open file table），并将表格中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示：

- 当前文件偏移量（调用 `read()` 和 `write()` 时更新，或使用 lseek()直接修改）
- 打开文件时所使用的状态标识（即，`open()` 的 flags 参数）
- 文件访问模式（如调用 `open()` 时所设置的只读模式、只写模式或读写模式）
- 与信号驱动相关的设置
- 对该文件 i-node 对象的引用
- 文件类型（例如：常规文件、套接字或 FIFO）和访问权限
- 一个指针，指向该文件所持有的锁列表
- 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳

下图展示了文件描述符、打开的文件句柄以及 inode 之间的关系，图中，两个进程拥有诸多打开的文件描述符。
![](https://notes-learning.oss-cn-beijing.aliyuncs.com/thtg9e/1616167666232-4da27112-018a-4ff6-bbec-f08930c5110e.jpeg)
在进程 A 中，文件描述符 1 和 30 都指向了同一个打开的文件句柄（标号 23）。这可能是通过调用 dup()、dup2()、fcntl()或者对同一个文件多次调用了 open()函数而形成的。

进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个打开的文件句柄（标号 73）。这种情形可能是在调用 fork()后出现的（即，进程 A、B 是父子进程关系），或者当某进程通过 UNIX 域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用 open 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。

此外，进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件句柄，但这些句柄均指向 i-node 表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open()调用。同一个进程两次打开同一个文件，也会发生类似情况。

## 总结

- 由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件
- 两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用 read()、write()或 lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。
- 要获取和修改打开的文件标志（例如：O_APPEND、O_NONBLOCK 和 O_ASYNC），可执行 fcntl()的 F_GETFL 和 F_SETFL 操作，其对作用域的约束与上一条颇为类似。
- 文件描述符标志（即，close-on-exec）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符

参考
\[1] <http://blog.chinaunix.net/uid-20633888-id-2747146.html>
\[2] <http://www.cppblog.com/guojingjia2006/archive/2012/11/21/195450.html>
\[3] <http://blog.csdn.net/kumu_linux/article/details/7877770>
\[4] 《Linux/UNIX 系统编程手册》

# File Descriptor 关联文件与配置

**/proc/PID/fd/** # 其中包含 PID 进程 打开的每个文件的一个条目，该条目由其文件描述符命名，并且是指向实际文件的符号链接。 因此，0 是标准输入，1 是标准输出，2 是标准错误，依此类推。
**/proc/PID/fdinfo/** # 其中包含 PID 进程 打开的每个文件的一个条目，该条目由其文件描述符命名。 该目录中的文件仅由进程所有者读取。 可以读取每个文件的内容以获得有关相应文件描述符的信息。 内容取决于相应文件描述符所引用的文件类型。

不过，每个条目中，都有 3 个基本信息：

- **pos** # 这是一个十进制数字，显示文件偏移量。This is a decimal number showing the file offset.
- **flags**# 这是一个八进制数字，显示文件访问模式和文件状态标志（请参阅 open（2））。如果设置了执行时关闭文件描述符标志，则标志还将包含值 O_CLOEXEC。This is an octal number that displays the file access mode and file status flags (see open(2)). If the close-on-exec file descriptor flag is set, then flags will also include the value O_CLOEXEC.
- **mnt_id** # 从 Linux 3.15 开始出现的此字段是包含此文件的安装点的 ID。请参见/ proc / \[pid] / mountinfo 的描述。This field, present since Linux 3.15, is the ID of the mount point containing this file. See the description of /proc/\[pid]/mountinfo.

根据该描述符所引用的文件类型，还有不同的信息会显示
/dev/net/tun 设备

- **iff** # PID 进程打开的 tun/tap 设备的名称
