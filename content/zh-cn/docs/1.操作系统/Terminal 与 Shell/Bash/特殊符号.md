---
title: "特殊符号"
linkTitle: "特殊符号"
weight: 20
---

# 概述

> 参考：
> 
> -

# Bash 中特殊符号的说明

这些特殊符号的作用，一般是在对 Linux 和 shell 有一定了解的基础上，才能明白其作用。

## `' '` 和 `" "`(单引号 和 双引号)

首先，单引号和双引号，都是为了解决中间有空格的问题。

因为空格在 Shell 中时作为一个很典型的分隔符，比如 string1=this is astring，这样执行就会报错。为了避免这个问题，因此就产生了单引号和双引号。

单引号引用的内容，所见即所得。即将单引号内的内容原样输出，或者描述为单引号里面看到的是什么就会输出什么。单引号是全引用，被单引号括起的内容不管是常量还是变量都不会发生替换。

```bash
~]# var=dablelv
~]# echo '$var'
$var
```

双引号引用的内容，所见非所得。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。双引号是部分引用，被双引号括起的内容常量还是常量，变量则会发生替换，替换成变量内容。

```bash
~]# var=dablelv
~]# echo "$var"
dablelv
```

无引号不使用引号定义字符串时，字符串不能包含空白字符（如 Space 或 Tab），需要该加引号，一般连续的字符串，数字，路径等可以不加引号。如果内容中有命令、变量等，会先把变量、命令解析出结果，然后在输出最终内容。

```bash
~]# str3=test String
-bash: String: 未找到命令
~]# echo $str3
~]#
```

可见，字符串中包含有空格时不实用引号括起来，将无法正常输出。

## `$()` 和 `` 用于命令替换

在 bash shell 中，$( ) 与`` (反引号) 都是用来做命令替换用(command substitution)的。

例如：version=$(uname -r) 和 version=`uname -r` 都可以使 version 得到内核的版本号

各自的优缺点：

- `` 基本上可用在全部的 unix shell 中使用，若写成 shell script ，其移植性比较高。但反单引号容易打错或看错。
- `$( )` 并不是所有 shell 都支持。

## `$[]` 和 `$(())`

它们是一样的，都是进行数学运算的。支持+ - */ %：分别为 “加、减、乘、除、取模”。但是注意，bash 只能作整数运算，对于浮点数是当作字符串处理的。

` c=2$ echo $(( a+b*c ))19$ echo $(( (a+b)/c ))6$ echo $(( (a*b)%c))1`

在 `$(( ))` 中的变量名称，可于其前面加 `$` 符号来替换，也可以不用，如：

`$(( $a + $b * $c))` 也可得到 19 的结果

此外，$(( )) 还可作不同进位(如二进制、八进位、十六进制)作运算呢，只是，输出结果皆为十进制而已：

echo $((16#2a)) 结果为 42 (16 进位转十进制)

## `[ ]` `test` 命令的另一种形式

注意：

- 你必须在左括号的右侧和右括号的左侧各加一个空格，否则会报错。
- test 命令使用标准的数学比较符号来表示字符串的比较，而用文本符号来表示数值的比较。很多人会记反了。使用反了，shell 可能得不到正确的结果。
- 大于符号或小于符号必须要转义，否则会被理解成重定向。
  - bash 的内部命令，\[和 test 是等同的。如果我们不用绝对路径指明，通常我们用的都是 bash 自带的命令。if/test 结构中的左中括号是调用 test 的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test 结构中并不是必须右中括号，但是新版的 Bash 中要求必须这样。
  - test 和 `[]` 中可用的比较运算符只有 `==` 和 `!=` ，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用 -eq，-gt 这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：`[ ab < bc ]`，结果为真，也就是返回状态为 0。`[ ]` 中的逻辑与和逻辑或使用 -a 和 -o 表示。
  - 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为 test 用途的中括号内不能使用正则。
  - 在一个 array 结构的上下文中，中括号用来引用数组中每个元素的编号。

## `(( ))` 和 `[[ ]]`

它们分别是\[ ]的针对数学比较表达式和字符串表达式的加强版。

注意：\[\[]]会把 0 开头的整型数字当成 8 进制数来处理，所以以 0 开头的整型数如果想要按照 10 进制处理需要使用\[]来处理

其中(( ))，不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号：

`[[` 是 bash 程序语言的关键字。并不是一个命令，`[[ ]]` 结构比 `[ ]` 结构更加通用。在 `[[` 和 `]]` 之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。

支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。

使用 `[[ ... ]]` 条件判断结构，而不是 `[ ... ]`，能够防止脚本中的许多逻辑错误。比如，`&&`、`||`、`<` 和 `>` 操作符能够正常存在于 `[[ ]]` 条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用 `if [[ $a != 1 && $a != 2 ]]`, 如果不适用双括号, 则为 `if [ $a -ne 1] && [ $a != 2 ]` 或者 `if [ $a -ne 1 -a $a != 2 ]`。

Bash 把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。

