---
title: NTP
linkTitle: NTP
date: 2024-02-23T12:27
weight: 20
---

# 概述

> 参考：
>
> - [Wiki, NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol)

**Network Time Protocol(网络时间协议，简称 NTP)** 是在数据网络潜伏时间可变的计算机系统之间通过分组交换进行时钟同步的一个网络[通信协议](/docs/4.数据通信/Protocol/通信协议.md)，位于 OSI 模型的应用层。自 1985 年以来，NTP 是目前仍在使用的最古老的互联网协议之一。NTP 由特拉华大学的 David L. Mills 设计。

NTP 意图将所有参与计算机的协调世界时（UTC）时间同步到几毫秒的误差内。:3 它使用 Marzullo 算法的修改版来选择准确的时间服务器，其设计旨在减轻可变网络延迟造成的影响。NTP 通常可以在公共互联网保持几十毫秒的误差，并且在理想的局域网环境中可以实现超过 1 毫秒的精度。不对称路由和拥塞控制可能导致 100 毫秒（或更高）的错误。

该协议通常描述为一种主从式架构，但它也可以用在点对点网络中，对等体双方可将另一端认定为潜在的时间源。:20 发送和接收时间戳采用用户数据报协议（UDP）的端口 123 实现。这也可以使用广播或多播，其中的客户端在最初的往返校准交换后被动地监听时间更新。]NTP 提供一个即将到来闰秒调整的警告，但不会传输有关本地时区或夏时制的信息。

当前协议为版本 4（NTPv4），这是一个 RFC 5905 文档中的建议标准。它向下兼容指定于 RFC 1305 的版本 3。

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-ae048176-3985-441b-86bb-8fcaf5569d90.jpeg)

NTP 的设计者 David L. Mills。

1979 年，网络时间同步技术在纽约的国家计算机会议上于运行在跨大西洋卫星网络的互联网服务上公开演示，这可能是该技术的首次公开演示。该技术后在 1981 年互联网工程笔记（IEN）173 中描述，并根据 RFC 778 文档开发为一个公开协议。该技术首先被部署在一个本地网络，作为 Hello 路由协议的一部分，并在 Fuzzball（一个用于网络原型的实验操作系统，已运行多年）中实现。

现在还有其他的相关网络工具。这包括 Daytime 和 Time 协议用以记录事件时间，以及互联网控制消息协议和 IP 时间戳选项（RFC 781）。更多完整的同步系统，虽然缺乏 NTP 的数据分析和时钟规律算法，包括 Unix 守护进程 timed 在内的软件其使用选举算法为所有客户端指定服务器。以及数字时间同步服务（Digital Time Synchronization Service，DTSS）使用类似构 NTP 阶层模型的服务器层次结构。

1985 年，NTPv0 被实现于 Fuzzball 和 Unix，文档化于 RFC 958 的 NTP 数据包头、和往返延迟和偏移计算都被留存至 NTPv4。尽管当时可用的计算机和网络相对较慢，但在跨大西洋链路上也获取了优于 100 毫秒的精度，在以太网网络上准确度为几十毫秒。

1988 年，一个更完整的 NTPv1 协议规范及相关的算法发表在 RFC 1059。它利用了 RFC 956 的文献中的实验结果和时钟滤波算法，并是第一个描述客户端-服务器和点对点网络模型的版本。1991 年，NTPv1 架构、协议和算法通过 David L. Mills 在 IEEE Transactions on Communications 发布的一篇文章得到了工程学界的更广泛关注。

1989 年，RFC 1119 发布通过有限状态机定义的 NTPv2，使用伪代码来描述其操作。它引入了一个管理协议和加密认证方案，它们留存至 NTPv4。社区批评 NTP 的设计缺乏形式正确性原则。他们的替代设计包括 Marzullo 算法，其修改版本已及时添加到 NTP。这个时代的大多数算法也大部分留存至 NTPv4。

1992 年，RFC 1305 定义了 NTPv3。该 RFC 包括一个对所有错误来源的分析，从参考时钟至最终客户端，这使帮助度量和选择最佳服务器成为可能（在其中几个候选者反对的情况下）。广播模式被引入。

在接下来的几年里，随着新特性的添加和算法的改进，显然还需要一个新的协议版本。\[6]2010 年，RFC 5905 发布了一个对 NTPv4 的建议规范，但该协议自那时以来已经显著改变，截至 2014 年，更新的 RFC 尚未发布。\[7]在 Mills 从特拉华大学退休后，该参考实现目前由 Harlan Stenn 保持为一个开放源代码项目。\[8]\[9]

时钟层

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444688-dd02f9db-d4f3-4ba6-b2a1-10daf2c80df3.jpeg)

美国海军天文台备用主时钟 Schriever AFB (Colorado)是一个第 0 层的 NTP 源

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444707-1f04a452-f5ae-4d30-abaa-6646e633ffa0.jpeg)

黄色箭头表示直接连接；红色箭头表示网络连接。

NTP 使用一个分层、半分层的时间源系统。该层次的每个级别被称为“stratum”，顶层分配为数字 0。一个通过阶层 n 同步的服务器将运行在阶层 n + 1。数字表示与参考时钟的距离，用于防止层次结构中的循环依赖性。阶层并不总是指示质量或可靠性；在阶层 3 的时间源得到比阶层 2 时间源更高的时间质量也很常见。电信系统对时钟层使用不同的定义。以下提供了阶层 0、1、2、3 的简要描述。

阶层 0（Stratum 0）

这些是高精度计时设备，例如原子钟（如铯、铷）、GPS 时钟或其他无线电时钟。它们生成非常精确的脉冲秒信号，触发所连接计算机上的中断和时间戳。阶层 0 设备也称为参考（基准）时钟。

阶层 1

这些与阶层 0 设备相连、在几微秒误差内同步系统时钟的计算机。阶层 1 服务器可能与其他阶层 1 服务器对等相连，以进行完整性检查和备份。\[10]它们也被称为主要（primary）时间服务器。

阶层 2

这些计算机通过网络与阶层 1 服务器同步。提供阶层 2 的计算机将查询多个阶层 1 服务器。阶层 2 计算机也可能与其他阶层 2 计算机对等相连，为对等组中的所有设备提供更健全稳定的时间。

阶层 3

这些计算机与阶层 2 的服务器同步。它们使用与阶层 2 相同的算法进行对等和数据采样，并可以自己作为服务器担任阶层 4 计算机，以此类推。

阶层的上限为 15；阶层 16 被用于标识设备未同步。每台计算机上的 NTP 算法相互构造一个贝尔曼-福特算法最短路径生成树，以最小化所有客户端到阶层 1 服务器的累积往返延迟。\[1]:20

时间戳

NTP 使用 64 比特的时间戳，其中 32 位表示秒，32 位表示秒的小数，给出一个每 232 秒（136 年）才会翻转的时间尺度，理论分辨率 2−32 秒（233 皮秒）。NTP 以 1900 年 1 月 1 日作为开始时间，因此第一次翻转将在 2036 年 2 月 7 日发生。

NTP 的未来版本可能将时间表示扩展到 128 位：其中 64 位表示秒，64 位表示秒的小数。当前的 NTPv4 格式支持“时代数字”（Era Number）和“时代偏移”（Era Offset），正确使用它们应该有助于解决日期翻转问题。据 Mills 称：“64 位的秒小数足以分辨光子以光速通过电子所需的时间。64 位的秒足以提供明确的时间表示，直到宇宙变暗。”

时钟同步算法\[编辑]

![](https://notes-learning.oss-cn-beijing.aliyuncs.com/lqlu60/1616161444690-fed573bb-2fbf-45f7-b1db-69f4d664acee.jpeg)
